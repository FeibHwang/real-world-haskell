import Data.List

-- Write a function that computes the number of elements in a list. To test
-- it, ensure that it gives the same answers as the standard length function. 
len :: [a] -> Int
len [] = 0
len xs = count 1 (tail xs)
    where count n [] = n
          count n ys = count (n + 1) (tail ys)

-- Write a function that computes the mean of a list, i.e., the sum of all
-- elements in the list divided by its length. (You may need to use the
-- fromIntegral function to convert the length of the list from an integer into
-- a floating-point number.)
mean :: Num a => [a] -> Fractional a => a 
mean [] = 0
mean xs = (sum xs) / fromIntegral(len xs)

-- Turn a list into a palindrome; i.e., it should read the same both backward
-- and forward. For example, given the list [1,2,3], your function should
-- return [1,2,3,3,2,1].
palindrome :: [a] -> [a]
palindrome [] = []
palindrome xs = xs ++ reverse xs

-- Not repeating the middle entry such that [1,2,3] becomes [1,2,3,2,1]
palindrome1 :: [a] -> [a]
palindrome1 [] = []
palindrome1 xs = xs ++ tail(reverse xs)

-- Write a function that determines whether its input list is a palindrome.
isPalindrome :: Eq a => [a] -> Bool
isPalindrome [] = True
isPalindrome xs | (mod (length xs) 2) == 0 = 
        front == revBack
    where split = splitAt (round((fromIntegral(length xs)) / 2)) xs
          front = fst split
          revBack = reverse (snd split) 
isPalindrome _ = False

-- Create a function that sorts a list of lists based on the length of each
-- sublist. (You may want to look at the sortBy function from the Data.List
-- module.)
sortLists xys = sortBy sizeCompare xys
    where sizeCompare xs ys | xsl == ysl = EQ
                            | xsl > ysl  = GT
                            | otherwise  = LT
            where xsl = length xs
                  ysl = length ys

-- Define a function that joins a list of lists together using a separator
-- value. intersperse :: a -> [[a]] -> [a]
-- The separator should appear between elements of the list, but it should not
-- follow the last element.
intersperse1 :: a -> [[a]] -> [a]
intersperse1 s xs
    | null xs         = []
    | length(xs) == 1 = head xs
    | otherwise       = head xs ++ [s] ++ (intersperse1 s (tail xs))

-- Using the binary tree type that we defined earlier in this chapter, write a
-- function that will determine the height of the tree. The height is the
-- largest number of hops from the root to an Empty. For example, the tree
-- Empty has height zero; Node "x" Empty Empty has height one; Node "x" Empty
-- (Node "y" Empty Empty) has height two; and so on.
data Tree a = Node a (Tree a) (Tree a)
            | Empty
              deriving (Show)

deepest Empty = 0
deepest (Node _ Empty Empty) = 1
deepest (Node _ left  Empty) = 1 + (deepest left)
deepest (Node _ Empty right) = 1 + (deepest right)
deepest (Node _ left  right) | ldepth > rdepth  = ldepth + 1
                             | otherwise        = rdepth + 1
        where ldepth = deepest left
              rdepth = deepest right

-- cleaner version?
clDeepest t = depth t
    where depth Empty                                  = 0
          depth (Node _ Empty Empty)                   = 1
          depth (Node _ left  Empty)                   = 1 + clDeepest left
          depth (Node _ Empty right)                   = 1 + clDeepest right
          depth (Node _ left  right) | ldepth > rdepth = 1 + ldepth
                                     | otherwise       = 1 + rdepth
                where ldepth = clDeepest left
                      rdepth = clDeepest right
                        
                
